// MoodMap WhatsApp Bot - OPTION 42 üöÄ
// IA Pure + Cartes Visuelles + Template Clean
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const twilio = require('twilio');
const axios = require('axios');
const fs = require('fs');
const { createCanvas, loadImage, registerFont } = require('canvas');
const path = require('path');

const app = express();
const port = process.env.PORT || 10000;

// Validation des variables d'environnement
if (!process.env.TWILIO_ACCOUNT_SID || !process.env.TWILIO_AUTH_TOKEN || !process.env.MISTRAL_API_KEY || !process.env.TWILIO_PHONE_NUMBER) {
  console.error('‚ùå ERREUR : Variables d\'environnement manquantes !');
  console.log('üîç Variables requises :');
  console.log(`TWILIO_ACCOUNT_SID: ${process.env.TWILIO_ACCOUNT_SID ? '‚úÖ D√©finie' : '‚ùå MANQUANTE'}`);
  console.log(`TWILIO_AUTH_TOKEN: ${process.env.TWILIO_AUTH_TOKEN ? '‚úÖ D√©finie' : '‚ùå MANQUANTE'}`);
  console.log(`MISTRAL_API_KEY: ${process.env.MISTRAL_API_KEY ? '‚úÖ D√©finie' : '‚ùå MANQUANTE'}`);
  console.log(`TWILIO_PHONE_NUMBER: ${process.env.TWILIO_PHONE_NUMBER ? '‚úÖ D√©finie' : '‚ùå MANQUANTE'}`);
  process.exit(1);
}

const client = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

app.use(bodyParser.urlencoded({ extended: false }));
app.use('/images', express.static('temp_images')); // Servir les images temporaires

// Cr√©er dossier pour images temporaires
if (!fs.existsSync('temp_images')) {
  fs.mkdirSync('temp_images');
}

// Chargement des donn√©es utilisateur
let userData = {};
if (fs.existsSync('userData.json')) {
  try {
    userData = JSON.parse(fs.readFileSync('userData.json'));
    const userCount = Object.keys(userData).length;
    const totalCards = Object.values(userData).reduce((sum, user) => sum + (user.cartes?.length || 0), 0);
    console.log('‚úÖ Donn√©es utilisateur restaur√©es depuis userData.json');
    console.log(`üìä ${userCount} utilisateurs recharg√©s, ${totalCards} cartes totales`);
  } catch (err) {
    console.error('‚ö†Ô∏è Erreur de lecture du fichier userData.json :', err);
  }
}

// Sauvegarde automatique toutes les minutes
setInterval(() => {
  try {
    fs.writeFileSync('userData.json', JSON.stringify(userData, null, 2));
    const userCount = Object.keys(userData).length;
    const totalCards = Object.values(userData).reduce((sum, user) => sum + (user.cartes?.length || 0), 0);
    console.log(`üíæ Donn√©es sauvegard√©es: ${userCount} users, ${totalCards} cartes`);
  } catch (err) {
    console.error('‚ùå Erreur sauvegarde:', err);
  }
}, 60000);

// Syst√®me m√©t√©o simplifi√© - 3 niveaux seulement
const meteoSimple = {
  joie: [
    { niveau: 1, texte: "Petit rayon", emoji: "üå§Ô∏è" },
    { niveau: 2, texte: "Soleil", emoji: "‚òÄÔ∏è" },
    { niveau: 3, texte: "Grand soleil", emoji: "üåû" }
  ],
  tristesse: [
    { niveau: 1, texte: "Nuages l√©gers", emoji: "‚õÖ" },
    { niveau: 2, texte: "Temps gris", emoji: "‚òÅÔ∏è" },
    { niveau: 3, texte: "Pluie", emoji: "üåßÔ∏è" }
  ],
  col√®re: [
    { niveau: 1, texte: "Vent l√©ger", emoji: "üçÉ" },
    { niveau: 2, texte: "Vent fort", emoji: "üí®" },
    { niveau: 3, texte: "Temp√™te", emoji: "‚õàÔ∏è" }
  ],
  peur: [
    { niveau: 1, texte: "Brume", emoji: "üå´Ô∏è" },
    { niveau: 2, texte: "Brouillard", emoji: "üå´Ô∏è" },
    { niveau: 3, texte: "Brouillard √©pais", emoji: "üå´Ô∏è" }
  ],
  surprise: [
    { niveau: 1, texte: "Arc-en-ciel timide", emoji: "üåà" },
    { niveau: 2, texte: "Arc-en-ciel", emoji: "üåà" },
    { niveau: 3, texte: "Arc-en-ciel √©clatant", emoji: "üåà" }
  ],
  motivation: [
    { niveau: 1, texte: "Brise fra√Æche", emoji: "üçÉ" },
    { niveau: 2, texte: "Vent dynamique", emoji: "üí®" },
    { niveau: 3, texte: "√ânergie pure", emoji: "‚ö°" }
  ],
  fatigue: [
    { niveau: 1, texte: "Temps calme", emoji: "üò∂‚Äçüå´Ô∏è" },
    { niveau: 2, texte: "Ciel lourd", emoji: "‚òÅÔ∏è" },
    { niveau: 3, texte: "Brouillard dense", emoji: "üå´Ô∏è" }
  ],
  s√©r√©nit√©: [
    { niveau: 1, texte: "Ciel paisible", emoji: "üå§Ô∏è" },
    { niveau: 2, texte: "Douceur", emoji: "‚òÅÔ∏è" },
    { niveau: 3, texte: "Zen total", emoji: "üåÖ" }
  ]
};

// Gradients couleurs pour les cartes visuelles
const meteoGradients = {
  joie: { start: '#FEF3C7', middle: '#FCD34D', end: '#F59E0B' }, // Jaune chaud
  tristesse: { start: '#DBEAFE', middle: '#93C5FD', end: '#60A5FA' }, // Bleu doux  
  col√®re: { start: '#FCE7F3', middle: '#F9A8D4', end: '#EC4899' }, // Rose-rouge
  peur: { start: '#F3F4F6', middle: '#D1D5DB', end: '#9CA3AF' }, // Gris 
  surprise: { start: '#EDE9FE', middle: '#C4B5FD', end: '#8B5CF6' }, // Violet
  motivation: { start: '#D1FAE5', middle: '#6EE7B7', end: '#10B981' }, // Vert √©nergique
  fatigue: { start: '#E5E7EB', middle: '#D1D5DB', end: '#6B7280' }, // Gris terne
  s√©r√©nit√©: { start: '#ECFDF5', middle: '#A7F3D0', end: '#6EE7B7' } // Vert zen
};

// Fonction d'appel Mistral
async function callMistral(prompt) {
  try {
    const response = await axios.post('https://api.mistral.ai/v1/chat/completions', {
      model: 'mistral-small-latest',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 200,
      temperature: 0.3
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.MISTRAL_API_KEY}`,
        'Content-Type': 'application/json'
      }
    });
    
    return response.data.choices[0].message.content.trim();
  } catch (error) {
    console.error('‚ùå Erreur Mistral:', error.response?.data || error.message);
    throw error;
  }
}

// Analyse √©motionnelle Mistral
async function analyzeEmotions(message) {
  console.log('üß† Analyse √©motionnelle Mistral...');
  
  const prompt = `Analyse les √©motions dans ce message en fran√ßais.

Message: "${message}"

IMPORTANT : R√©ponds UNIQUEMENT avec du JSON pur, sans balises markdown, sans triple backticks, sans texte autour.

Format JSON exact attendu :
{
  "emotions": [
    {"emotion": "joie", "intensite": 7},
    {"emotion": "gratitude", "intensite": 5}
  ]
}

R√®gles strictes :
- 1 √† 3 √©motions maximum
- Intensit√© entre 1 et 10
- Noms d'√©motions simples : joie, tristesse, col√®re, peur, surprise, motivation, fatigue, s√©r√©nit√©, gratitude, etc.
- INTERDICTION ABSOLUE d'utiliser l'anglais
- JSON pur seulement, pas de markdown
- Pas de texte explicatif avant ou apr√®s le JSON`;

  try {
    const response = await callMistral(prompt);
    
    // Nettoyage r√©ponse Mistral (enlever markdown si pr√©sent)
    let cleanResponse = response.trim();
    if (cleanResponse.includes('```json')) {
      cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    }
    
    const analysis = JSON.parse(cleanResponse);
    
    // Validation
    if (!analysis.emotions || !Array.isArray(analysis.emotions)) {
      throw new Error('Format JSON invalide');
    }
    
    // Nettoyage et validation des √©motions
    analysis.emotions = analysis.emotions.filter(e => 
      e.emotion && 
      typeof e.intensite === 'number' && 
      e.intensite >= 1 && 
      e.intensite <= 10
    ).slice(0, 3); // Max 3 √©motions
    
    return analysis;
  } catch (error) {
    console.error('‚ùå Erreur analyse √©motions:', error);
    // Fallback
    return {
      emotions: [{ emotion: "neutre", intensite: 5 }]
    };
  }
}

// Validation stricte des patterns IA
function validatePattern(pattern, insight) {
  // V√©rification longueur
  if (!pattern || !insight || pattern.length < 8 || insight.length < 8) return false;
  if (pattern.length > 80 || insight.length > 80) return false;
  
  // Mots interdits (IA qui sait pas quoi dire)
  const forbiddenWords = ['semble', 'peut-√™tre', 'probablement', 'il se pourrait', 'pourrait', 'aucun'];
  const patternLower = pattern.toLowerCase();
  const insightLower = insight.toLowerCase();
  
  if (forbiddenWords.some(word => patternLower.includes(word) || insightLower.includes(word))) {
    return false;
  }
  
  // Validation fran√ßais plus robuste
  const frenchIndicators = ['tu', 'te', 'ton', 'tes', 'quand', 'avec', 'pour', 'dans', 'sur', 'est', 'sont'];
  const hasFrenchPattern = frenchIndicators.some(word => patternLower.includes(word));
  const hasFrenchInsight = frenchIndicators.some(word => insightLower.includes(word));
  
  if (!hasFrenchPattern || !hasFrenchInsight) return false;
  
  // V√©rification anglais (heuristique simple)
  const englishWords = ['you', 'are', 'when', 'with', 'your', 'seem', 'feel', 'the', 'and'];
  const hasEnglish = englishWords.some(word => 
    patternLower.includes(word) || insightLower.includes(word));
  
  return !hasEnglish;
}

// D√©tection de patterns avec IA + validation stricte
async function detectPatternWithAI(userCards) {
  if (!userCards || userCards.length < 3) {
    console.log(`‚ÑπÔ∏è Pas assez de cartes pour pattern (${userCards?.length || 0}/3 minimum)`);
    return null;
  }
  
  console.log('üîç D√©tection pattern IA...');
  
  const recentCards = userCards.slice(-7); // 7 derni√®res cartes
  console.log(`üìä Analyse de ${recentCards.length} cartes r√©centes`);
  
  const prompt = `Langue : FRAN√áAIS UNIQUEMENT.
Format : EXACTEMENT deux lignes.

Pattern: [observation factuelle croisant √©motions + contexte + timing, max 15 mots]
Insight: [suggestion douce au conditionnel, max 15 mots]

Donn√©es r√©centes avec contexte temporal :
${recentCards.map((c, i) => {
  const date = new Date(c.timestamp);
  const dayName = ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'][date.getDay()];
  const hour = date.getHours();
  const period = hour < 12 ? 'matin' : hour < 18 ? 'apr√®s-midi' : 'soir';
  return `${dayName} ${period} (${hour}h): "${c.message}" ‚Üí ${c.emotions.map(e => `${e.emotion}(${e.intensite}/10)`).join(', ')}`;
}).join('\n')}

MISSION : Trouve des corr√©lations subtiles entre √©motions, contexte, timing, mots-cl√©s.

Exemples d'insights EXCELLENTS (au conditionnel) :
Pattern: Motivation plus forte le matin quand tu parles de projets
Insight: Planifier tes t√¢ches cr√©atives avant 10h pourrait am√©liorer ton efficacit√©

Pattern: √âmotions intenses les jours commen√ßant par M  
Insight: Pr√©parer ces journ√©es avec des activit√©s apaisantes pourrait aider

Pattern: Mots positifs doublent quand tu mentionnes des personnes
Insight: Cultiver davantage tes relations sociales pourrait am√©liorer ton bien-√™tre

INTERDICTIONS :
- Pas de patterns √©vidents ("tu aimes X car tu dis aimer X")
- Pas d'anglais, pas d'imp√©ratif ("√©vite", "prends", "fais")
- Utilise "pourrait", "semblerait", "il se pourrait que"
- Sois fin, perspicace, utile

Si RIEN de subtil √† dire, r√©ponds :
Pattern: Donn√©es insuffisantes pour pattern fin
Insight: Continuer √† partager pourrait r√©v√©ler de nouveaux motifs`;

  try {
    const response = await callMistral(prompt);
    console.log('üîç R√©ponse IA pattern brute:', response);
    
    // Extraction avec regex
    const match = response.match(/Pattern:\s*(.+)\nInsight:\s*(.+)/i);
    if (!match) {
      console.log('‚ùå Format pattern invalide');
      return null;
    }
    
    const [_, pattern, insight] = match;
    const cleanPattern = pattern.trim();
    const cleanInsight = insight.trim();
    
    console.log(`üîç Pattern extrait: "${cleanPattern}"`);
    console.log(`üîç Insight extrait: "${cleanInsight}"`);
    
    // Validation stricte
    if (!validatePattern(cleanPattern, cleanInsight)) {
      console.log('‚ùå Pattern rejet√© par validation');
      return null;
    }
    
    // V√©rification "aucun motif"
    if (cleanPattern.toLowerCase().includes("aucun motif") || 
        cleanInsight.toLowerCase().includes("aucun insight")) {
      console.log('‚ÑπÔ∏è Aucun pattern d√©tect√© par IA');
      return null;
    }
    
    console.log('‚úÖ Pattern valid√© et accept√©');
    return {
      pattern: cleanPattern,
      insight: cleanInsight
    };
    
  } catch (error) {
    console.error('‚ùå Erreur d√©tection pattern:', error);
    return null;
  }
}

// G√©n√©ration m√©t√©o avec priorit√© stress/fatigue ‚â•7
function generateMeteo(emotions) {
  if (!emotions || emotions.length === 0) {
    return { emoji: "‚òÅÔ∏è", texte: "Temps neutre", famille: "s√©r√©nit√©" };
  }
  
  // PRIORIT√â 1 : Stress/fatigue intense (‚â•7) force la m√©t√©o
  const stressIntense = emotions.find(e => e.emotion === 'stress' && e.intensite >= 7);
  if (stressIntense) {
    return { emoji: "‚õàÔ∏è", texte: "Temp√™te", famille: "col√®re" };
  }
  
  const fatigueIntense = emotions.find(e => e.emotion === 'fatigue' && e.intensite >= 7);
  if (fatigueIntense) {
    return { emoji: "üå´Ô∏è", texte: "Brouillard dense", famille: "fatigue" };
  }
  
  const anxieteIntense = emotions.find(e => e.emotion === 'anxi√©t√©' && e.intensite >= 7);
  if (anxieteIntense) {
    return { emoji: "üå´Ô∏è", texte: "Brouillard √©pais", famille: "peur" };
  }
  
  // PRIORIT√â 2 : √âmotion dominante normale
  const emotionDominante = emotions.reduce((prev, current) => 
    current.intensite > prev.intensite ? current : prev
  );
  
  const familleMeteo = meteoSimple[emotionDominante.emotion] || meteoSimple.s√©r√©nit√©;
  
  let niveau = 1;
  if (emotionDominante.intensite >= 7) niveau = 3;
  else if (emotionDominante.intensite >= 4) niveau = 2;
  
  const meteo = familleMeteo[niveau - 1];
  return {
    emoji: meteo.emoji,
    texte: meteo.texte,
    famille: emotionDominante.emotion
  };
}

// Emojis √©motions
function getEmotionEmoji(emotion) {
  const emojis = {
    joie: "üòä",
    tristesse: "üòî",
    col√®re: "üò†",
    peur: "üò∞",
    surprise: "üòÆ",
    motivation: "üí™",
    fatigue: "üò¥",
    s√©r√©nit√©: "üòå",
    gratitude: "üôè",
    amour: "‚ù§Ô∏è",
    espoir: "üåü",
    d√©ception: "üòû",
    fiert√©: "üòä",
    inqui√©tude: "üòü",
    excitation: "ü§©",
    calme: "üòå",
    stress: "üò∞",
    satisfaction: "üòå",
    nostalgie: "üòå",
    neutre: "üòê"
  };
  return emojis[emotion] || "üòê";
}

// Fonction utilitaire pour cr√©er un gradient
function createGradient(ctx, width, height, colors) {
  const gradient = ctx.createLinearGradient(0, 0, 0, height);
  gradient.addColorStop(0, colors.start);
  gradient.addColorStop(0.5, colors.middle);
  gradient.addColorStop(1, colors.end);
  return gradient;
}

// Fonction utilitaire pour wrapper le texte
function wrapText(ctx, text, maxWidth) {
  const words = text.split(' ');
  const lines = [];
  let currentLine = words[0];

  for (let i = 1; i < words.length; i++) {
    const word = words[i];
    const width = ctx.measureText(currentLine + ' ' + word).width;
    if (width < maxWidth) {
      currentLine += ' ' + word;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  lines.push(currentLine);
  return lines;
}

// FONCTION PRINCIPALE : G√©n√©ration carte visuelle
async function generateMoodImage(analysis, message, meteo, pattern, timestamp) {
  const width = 540;
  const height = 680;
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');

  // Fond gradient selon la m√©t√©o
  const gradientColors = meteoGradients[meteo.famille] || meteoGradients.s√©r√©nit√©;
  const bgGradient = createGradient(ctx, width, height, gradientColors);
  
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, width, height);

  // Coins arrondis pour la carte
  ctx.beginPath();
  ctx.roundRect(20, 20, width - 40, height - 40, 30);
  ctx.clip();
  ctx.fillRect(0, 0, width, height);

  // Reset clip pour les √©l√©ments suivants
  ctx.restore();
  ctx.save();

  // Header m√©t√©o
  ctx.fillStyle = '#374151';
  ctx.font = 'bold 24px Arial, sans-serif';
  ctx.fillText(`${meteo.emoji} ${meteo.texte}`, 50, 80);

  // Citation utilisateur (encadr√© blanc)
  const quoteX = 50;
  const quoteY = 120;
  const quoteWidth = width - 100;
  const quoteHeight = 80;

  // Fond blanc translucide pour la citation
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  ctx.beginPath();
  ctx.roundRect(quoteX, quoteY, quoteWidth, quoteHeight, 15);
  ctx.fill();

  // Texte de la citation
  ctx.fillStyle = '#374151';
  ctx.font = 'italic 16px Arial, sans-serif';
  const quotedMessage = `"${message}"`;
  const quoteLines = wrapText(ctx, quotedMessage, quoteWidth - 40);
  
  quoteLines.forEach((line, index) => {
    ctx.fillText(line, quoteX + 20, quoteY + 30 + (index * 20));
  });

  // √âmotions (encadr√© blanc)
  const emotionsX = 50;
  const emotionsY = 230;
  const emotionsWidth = width - 100;
  const emotionsHeight = analysis.emotions.length * 35 + 20;

  ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
  ctx.beginPath();
  ctx.roundRect(emotionsX, emotionsY, emotionsWidth, emotionsHeight, 15);
  ctx.fill();

  // Texte des √©motions
  ctx.fillStyle = '#374151';
  ctx.font = '18px Arial, sans-serif';
  
  analysis.emotions.forEach((emotion, index) => {
    const emoji = getEmotionEmoji(emotion.emotion);
    const emotionText = emotion.emotion.charAt(0).toUpperCase() + emotion.emotion.slice(1);
    const text = `${emoji} ${emotionText} : ${emotion.intensite}/10`;
    ctx.fillText(text, emotionsX + 20, emotionsY + 35 + (index * 35));
  });

  // Pattern & Insight (si pr√©sent)
  if (pattern) {
    const patternY = emotionsY + emotionsHeight + 20;
    const patternHeight = 120;

    // Fond blanc translucide pour pattern/insight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.beginPath();
    ctx.roundRect(50, patternY, width - 100, patternHeight, 15);
    ctx.fill();

    // Badge "TENDANCE"
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.roundRect(70, patternY + 15, 120, 25, 12);
    ctx.fill();

    ctx.fillStyle = '#374151';
    ctx.font = 'bold 12px Arial, sans-serif';
    ctx.fillText('üìä TENDANCE', 80, patternY + 32);

    // Texte pattern
    ctx.font = '14px Arial, sans-serif';
    const patternLines = wrapText(ctx, pattern.pattern, width - 140);
    patternLines.forEach((line, index) => {
      ctx.fillText(line, 70, patternY + 55 + (index * 16));
    });

    // Badge "PISTE"
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.roundRect(70, patternY + 75, 100, 25, 12);
    ctx.fill();

    ctx.fillStyle = '#374151';
    ctx.font = 'bold 12px Arial, sans-serif';
    ctx.fillText('üß≠ PISTE', 80, patternY + 92);

    // Texte insight
    ctx.font = '14px Arial, sans-serif';
    const insightLines = wrapText(ctx, pattern.insight, width - 140);
    insightLines.forEach((line, index) => {
      ctx.fillText(line, 70, patternY + 115 + (index * 16));
    });
  }

  // Date en bas
  const date = new Date(timestamp);
  const options = { 
    weekday: 'long', 
    day: 'numeric', 
    month: 'long', 
    year: 'numeric' 
  };
  const formattedDate = date.toLocaleDateString('fr-FR', options);
  const finalDate = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);

  ctx.fillStyle = '#6B7280';
  ctx.font = '14px Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(finalDate, width / 2, height - 40);

  // Sauvegarder l'image
  const filename = `mood_card_${Date.now()}.png`;
  const filepath = path.join('temp_images', filename);
  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(filepath, buffer);

  console.log(`üé® Carte g√©n√©r√©e: ${filename}`);
  return {
    filepath,
    filename,
    url: `${process.env.BASE_URL || 'https://your-app.onrender.com'}/images/${filename}`
  };
}

// G√©n√©ration carte Option 42 avec image
async function generateOption42Card(analysis, messageOriginal, userId) {
  const meteo = generateMeteo(analysis.emotions);
  console.log(`üå§Ô∏è M√©t√©o g√©n√©r√©e: ${meteo.emoji} ${meteo.texte}`);
  
  // D√©tection pattern IA
  const userCards = userData[userId]?.cartes || [];
  console.log(`üìä Utilisateur ${userId} a ${userCards.length} cartes`);
  
  const pattern = await detectPatternWithAI(userCards);
  console.log(`üîç Pattern d√©tect√©: ${pattern ? 'OUI' : 'NON'}`);
  
  // G√©n√©rer l'image
  const imageData = await generateMoodImage(
    analysis, 
    messageOriginal, 
    meteo, 
    pattern, 
    new Date().toISOString()
  );
  
  return {
    imageData,
    meteoEmoji: meteo.emoji,
    meteoTexte: meteo.texte,
    hasPattern: !!pattern,
    patternData: pattern
  };
}

// Stockage carte avec patterns complets
function stockerCarte(userId, carteData, analysis, messageOriginal) {
  if (!userData[userId]) {
    userData[userId] = { cartes: [], preferences: {} };
  }
  
  const carte = {
    id: Date.now(),
    timestamp: new Date().toISOString(),
    message: messageOriginal,
    emotions: analysis.emotions,
    meteoEmoji: carteData.meteoEmoji,
    meteoTexte: carteData.meteoTexte,
    hasPattern: carteData.hasPattern,
    imageFilename: carteData.imageData.filename
  };
  
  // Bien stocker le pattern complet
  if (carteData.hasPattern && carteData.patternData) {
    carte.pattern = carteData.patternData.pattern;
    carte.insight = carteData.patternData.insight;
    carte.patternData = carteData.patternData;
  }
  
  userData[userId].cartes.push(carte);
  
  // Limite √† 100 cartes par utilisateur
  if (userData[userId].cartes.length > 100) {
    userData[userId].cartes = userData[userId].cartes.slice(-100);
  }
  
  console.log(`üíæ Carte √©motionnelle stock√©e pour ${userId}`);
}

// Nettoyage p√©riodique des images temporaires (garde seulement les 50 derni√®res)
setInterval(() => {
  try {
    const files = fs.readdirSync('temp_images')
      .filter(file => file.endsWith('.png'))
      .map(file => ({
        name: file,
        time: fs.statSync(path.join('temp_images', file)).mtime.getTime()
      }))
      .sort((a, b) => b.time - a.time);

    if (files.length > 50) {
      const filesToDelete = files.slice(50);
      filesToDelete.forEach(file => {
        fs.unlinkSync(path.join('temp_images', file.name));
      });
      console.log(`üßπ Nettoyage: ${filesToDelete.length} images supprim√©es`);
    }
  } catch (err) {
    console.error('‚ùå Erreur nettoyage images:', err);
  }
}, 60000 * 10); // Toutes les 10 minutes

// Routes principales
app.post('/webhook', async (req, res) => {
  const message = req.body.Body?.trim();
  const from = req.body.From;
  
  if (!message || !from) {
    return res.sendStatus(400);
  }
  
  const userId = from;
  console.log(`üì± Message re√ßu de ${userId}: "${message}"`);
  
  try {
    // D√©tection des commandes en PREMIER (avant analyse √©motionnelle)
    const messageClean = message.toLowerCase().trim();
    
    // Commandes exactes
    if (messageClean === 'hello' || messageClean === 'salut') {
      console.log('üîß AVANT ENVOI hello');
      await client.messages.create({
        body: 'üåà Bienvenue sur MoodMap Option 42 ! Raconte-moi ce que tu ressens ou ce qui t\'a travers√© aujourd\'hui üòä',
        from: `whatsapp:${process.env.TWILIO_PHONE_NUMBER}`,
        to: from
      });
      console.log('‚úÖ APR√àS ENVOI hello');
      res.writeHead(200, {'Content-Type': 'text/xml'});
      res.end('<Response></Response>');
      return;
    }
    
    // [Autres commandes restent identiques...]
    
    // Analyse √©motionnelle principale
    const analysis = await analyzeEmotions(message);
    const carteData = await generateOption42Card(analysis, message, userId);
    
    // Stockage
    stockerCarte(userId, carteData, analysis, message);
    
    // Envoi IMAGE au lieu de texte
    console.log('üîß AVANT ENVOI carte visuelle');
    await client.messages.create({
      mediaUrl: [carteData.imageData.url],
      from: `whatsapp:${process.env.TWILIO_PHONE_NUMBER}`,
      to: from
    });
    console.log('‚úÖ APR√àS ENVOI carte visuelle');
    
    res.writeHead(200, {'Content-Type': 'text/xml'});
    res.end('<Response></Response>');
    
  } catch (error) {
    console.error('‚ùå Erreur traitement message:', error);
    
    try {
      console.log('üö® AVANT ENVOI erreur');
      await client.messages.create({
        body: '‚ùå D√©sol√©, je rencontre une difficult√© technique. Peux-tu r√©essayer ?',
        from: `whatsapp:${process.env.TWILIO_PHONE_NUMBER}`,
        to: from
      });
      console.log('üö® APR√àS ENVOI erreur');
    } catch (sendError) {
      console.error('‚ùå Erreur envoi message d\'erreur:', sendError);
    }
    
    res.writeHead(500, {'Content-Type': 'text/xml'});
    res.end('<Response></Response>');
  }
});

// Route d'export des donn√©es
app.get('/export', (req, res) => {
  res.json(userData);
});

// Health check
app.get('/health', (req, res) => {
  const userCount = Object.keys(userData).length;
  const totalCards = Object.values(userData).reduce((sum, user) => sum + (user.cartes?.length || 0), 0);
  
  res.json({
    status: 'OK',
    version: 'Option 42 V2.0 - Cartes Visuelles',
    users: userCount,
    cards: totalCards,
    timestamp: new Date().toISOString()
  });
});

// D√©marrage serveur
app.listen(port, () => {
  console.log('üöÄ MoodMap WhatsApp Bot - OPTION 42 V2.0 d√©marr√© sur port', port);
  console.log('üé® G√©n√©ration cartes visuelles activ√©e');
  console.log('üéØ IA Pure avec validation stricte');
  console.log('‚ö° 2 appels Mistral par carte seulement');
  console.log('üß† Patterns intelligents automatiques');
  console.log('üõ°Ô∏è Fallback robuste int√©gr√©');
  console.log('üåà Cartes pastels modernes pour WhatsApp');
  console.log('üí™ Ready for visual revolution !');
});
